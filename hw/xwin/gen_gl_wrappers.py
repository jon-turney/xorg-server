#!/usr/bin/python
#
# Comedy python script to generate cdecl to stdcall wrappers for GL functions
#
# XXX: this should use the XML description of GL functions in Mesa as it's
# input, or http://www.opengl.org/registry/api/gl.spec if only I'd noticed
# that first...
#
#
# Copyright (c) Jon TURNEY 2009
#
# Permission is hereby granted, free of charge, to any person obtaining a
# copy of this software and associated documentation files (the "Software"),
# to deal in the Software without restriction, including without limitation
# the rights to use, copy, modify, merge, publish, distribute, sublicense,
# and/or sell copies of the Software, and to permit persons to whom the
# Software is furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
# THE ABOVE LISTED COPYRIGHT HOLDER(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
# OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
# ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
# DEALINGS IN THE SOFTWARE.
#
# Except as contained in this notice, the name(s) of the above copyright
# holders shall not be used in advertising or otherwise to promote the sale,
# use or other dealings in this Software without prior written authorization.
#

import sys
import re

r1 = re.compile(r'GLAPI\s(.*)\s(?:GL|)APIENTRY\s(\S*)\s?\((.*)\);')
r2 = re.compile(r'#define\sSET_(\S*)\(')
r3 = re.compile(r'glWindowPos.*MESA')

print '/* Automatically generated by ' + sys.argv[0] + ' DO NOT EDIT */'
print ''

#
# look for all the SET_ macros in dispatch.h, this is the set of functions
# we need to generate
#

dispatch = {}

fh = open('../../glx/dispatch.h')
dispatchh = fh.readlines()

for line in dispatchh :
        line = line.strip()
        m1 = r2.search(line)

        if m1 :
                dispatch[m1.group(1)] = 1

del dispatch['by_offset']

#
# search gl.h for GL 1.0 and 1.1 functions, and generate stdcall wrappers
# which call the function directly
#

wrappers = {}
l = ''

fh = open('/usr/include/GL/gl.h')
gldoth = fh.readlines()

for line in gldoth :
        line = line.strip()

        if line == '* OpenGL 1.2' :
                break

        # some function definitions are broken up over multiple lines, so treat ',' as a continuation character
        l = l + line
        if l.endswith(',') :
                continue

        m1 = r1.search(l)
        if m1 :
                returntype = m1.group(1)
                funcname = m1.group(2)
                arglist = m1.group(3).strip()
                print 'static ' + returntype + ' ' + funcname + 'Wrapper(' + arglist + ')'
                print '{'
                print '  if (glxWinDebugSettings.enableGLcallTrace) ErrorF("'+ funcname + '\\n");'
                print '  glWinDirectProcCalls++;'
                if returntype == 'void' :
                        print '  ' +  funcname + '(',
                else :
                        print '  return ' +  funcname + '(',

                if arglist != 'void' :
                        a =  arglist.split(',')
                        b = []
                        for arg in a :
                                arg  = arg[arg.rfind(' '):]
                                if arg.find('[') > 0 :
                                        arg  = arg[:arg.find('[')]
                                if arg.find('*') > 0 :
                                        arg = arg[arg.find('*')+1:]
                                arg = arg.strip()
                                b.append(arg)
                        print ', '.join(b),

                print ');'
                print "}\n"
                wrappers[funcname] = 1
        l = ''

#
# search glext.h for 1.2+ functions we need to generate wrappers for
# these wrappers need to use wglGetProcAddress()
#

fh = open('/usr/include/GL/glext.h')
glextdoth = fh.readlines()

for line in glextdoth :
        line = line.strip()
        m1 = r1.search(line)
        if m1 :
                returntype = m1.group(1)
                funcname = m1.group(2)
                arglist = m1.group(3).strip()

# Avoid generating wrappers which aren't referenced by the dispatch table
                if not dispatch.has_key(funcname[2:]) :
                        print '/* No wrapper for ' + funcname + ', not in dispatch table */'
                        continue

# sigh, glext.h doesn't name the formal parameters, so we have to make up some names...
                if arglist != 'void' :
                        a =  arglist.split(',')
                        for index in range(len(a)) :
                                a[index] = a[index] + ' ' + chr(ord('a') + index)
                        arglist = ','.join(a)

                print 'static ' + returntype + ' ' + funcname + 'Wrapper(' + arglist + ')'
                print '{'

#
# special case: Windows OpenGL implementations are far more likely to have GL_ARB_window_pos than GL_MESA_window_pos,
# so arrange for the wrapper to use the ARB strings to find functions...
#
                stringname = funcname
                m2 = r3.search(funcname)
                if m2 :
                        stringname = stringname.replace('MESA','ARB')

                if returntype == 'void' :
                        print '  RESOLVE(PFN' + funcname.upper() + 'PROC, "' + stringname + '");'
                        print '  if (glxWinDebugSettings.enableGLcallTrace) ErrorF("'+ funcname + '\\n");'
                        print '  proc(',
                else :
                        print '  RESOLVE_RET(PFN' + funcname.upper() + 'PROC, "' + stringname + '", FALSE);'
                        print '  if (glxWinDebugSettings.enableGLcallTrace) ErrorF("'+ funcname + '\\n");'
                        print '  return proc(',

                if arglist != 'void' :
                        a =  arglist.split(',')
                        b = []
                        for arg in a :
                                if arg.count(' ') == 0:
                                        arg = arg
                                else :
                                        arg  = arg[arg.rfind(' '):]
                                        if arg.find('[') > 0 :
                                                arg  = arg[:arg.find('[')]
                                        if arg.find('*') > 0 :
                                                arg = arg[arg.find('*')+1:]
                                        arg = arg.strip()
                                b.append(arg)
                        print ', '.join(b),

                print ');'
                print "}\n"
                wrappers[funcname] = 1

# generate function to setup the dispatch table, which sets each
# dispatch table entry to point to it's wrapper function
# (assuming we were able to make one)

print 'void glWinSetupDispatchTable(void)'
print '{'
print '  struct _glapi_table *disp = _glapi_get_dispatch();'
print '  gl_dispatch_debugging();\n'

for d in dispatch.keys() :
        if wrappers.has_key('gl' + d) :
                print '  SET_'+ d + '(disp, gl' + d + 'Wrapper);'
        else :
                print '#warning  No wrapper for gl' + d + '!'

print '}'