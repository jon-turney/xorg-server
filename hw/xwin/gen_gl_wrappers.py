#!/usr/bin/python
#
# Comedy python script to generate cdecl to stdcall wrappers for GL functions
#
# XXX: this should use the XML description of GL functions in Mesa as it's
# input, if only I'd noticed that first...
#
# Copyright (c) Jon TURNEY 2009
#
# Permission is hereby granted, free of charge, to any person obtaining a
# copy of this software and associated documentation files (the "Software"),
# to deal in the Software without restriction, including without limitation
# the rights to use, copy, modify, merge, publish, distribute, sublicense,
# and/or sell copies of the Software, and to permit persons to whom the
# Software is furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
# THE ABOVE LISTED COPYRIGHT HOLDER(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
# OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
# ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
# DEALINGS IN THE SOFTWARE.
#
# Except as contained in this notice, the name(s) of the above copyright
# holders shall not be used in advertising or otherwise to promote the sale,
# use or other dealings in this Software without prior written authorization.
#

import sys
import re

r1 = re.compile(r'GLAPI\s(.*)\sAPIENTRY\s(\S*)\s?\((.*)\);')

print '/* Automatically generated by ' + sys.argv[0] + ' DO NOT EDIT */'
print ''


fh = open('/usr/include/w32api/GL/gl.h')
gldoth = fh.readlines()

for line in gldoth :
        line = line.strip()
        if line == '/* 1.2 functions */' :
                break
        m1 = r1.search(line)
        if m1 :
                returntype = m1.group(1)
                funcname = m1.group(2)
                arglist = m1.group(3).strip()
                print 'static ' + returntype + ' ' + funcname + 'Wrapper(' + arglist + ')'
                print '{'
                print '  if (glWinDebugSettings.enableGLcallTrace) ErrorF("'+ funcname + '\\n");'
                print '  glWinDirectProcCalls++;'
                if returntype == 'void' :
                        print '  ' +  funcname + '(',
                else :
                        print '  return ' +  funcname + '(',

                if arglist != 'void' :
                        a =  arglist.split(',')
                        b = []
                        for arg in a :
                                arg  = arg[arg.rfind(' '):]
                                if arg.find('[') > 0 :
                                        arg  = arg[:arg.find('[')]
                                if arg.find('*') > 0 :
                                        arg = arg[arg.find('*')+1:]
                                arg = arg.strip()
                                b.append(arg)
                        print ', '.join(b),

                print ');'
                print "}\n"

fh = open('/usr/include/w32api/GL/glext.h')
glextdoth = fh.readlines()


for line in glextdoth :
        line = line.strip()
        m1 = r1.search(line)
        if m1 :
                returntype = m1.group(1)
                funcname = m1.group(2)
                arglist = m1.group(3).strip()

# sigh, glext.h doesn't name the formal parameters, so we have to make up some names...
                if arglist != 'void' :
                        a =  arglist.split(',')
                        for index in range(len(a)) :
                                a[index] = a[index] + ' ' + chr(ord('a') + index)
                        arglist = ','.join(a)

                print 'static ' + returntype + ' ' + funcname + 'Wrapper(' + arglist + ')'
                print '{'

                if returntype == 'void' :
                        print '  RESOLVE(PFN' + funcname.upper() + 'PROC, "' + funcname + '");'
                        print '  if (glWinDebugSettings.enableGLcallTrace) ErrorF("'+ funcname + '\\n");'
                        print '  proc(',
                else :
                        print '  RESOLVE_RET(PFN' + funcname.upper() + 'PROC, "' + funcname + '", FALSE);'
                        print '  if (glWinDebugSettings.enableGLcallTrace) ErrorF("'+ funcname + '\\n");'
                        print '  return proc(',

                if arglist != 'void' :
                        a =  arglist.split(',')
                        b = []
                        for arg in a :
                                if arg.count(' ') == 0:
                                        arg = arg
                                else :
                                        arg  = arg[arg.rfind(' '):]
                                        if arg.find('[') > 0 :
                                                arg  = arg[:arg.find('[')]
                                        if arg.find('*') > 0 :
                                                arg = arg[arg.find('*')+1:]
                                        arg = arg.strip()
                                b.append(arg)
                        print ', '.join(b),

                print ');'
                print "}\n"
